import numpy as np

'''
ДЕМОНСТРАЦИЯ ПРИМИМНЕНИЯ БИБЛИОТЕКИ NumPy
Имитация шифрования с использованием библиотеки NumPy
Для демонстрации необходим файл test.txt
Алгоритм шифрования:
1. Каждый символ текста переводится в двоичную систему исчисления
2. Из бинарных данных формируются матрицы 8x8
3. Матрицы транспонируются
4. Матрицы построчно переформатируются в список бинарных значений
5. Последовательность бинарных данных переводится обратно в символы таблицы ASCII
На выходе получаем "зашифрованный" нечитаемый текст
Расшифровка происходит в обратном порядке
Текст читается из файла file_name
Зашифрованный текст записывается в файл file_name_encrypted
Особенности:
1. Возможности алгоритма ограничены 128-ю символами таблицы ASCII (https://www.sg-electronic-systems.com/ascii-table/),
т.е. 8-ю битами в двоичном виде на один символ
2. Чтобы сформировать полные блоки бинарных данных 8x8,
начальный текст дополняется значениями нулевого символа '00000000' (https://symbl.cc/ru/0000/)
3. Алгоритм расшифровки практически идентичен алгоритму шифрования,
но необходимо из бинарной последовательности удалить "хвост" нулевых символов '00000000',
добавленный при шифровании (этот функционал реализован, можно расшифровать файл этим же скриптом,
поменяв названия файлов)
4. Чтобы не создавать массив двумерных матриц для их последующего транспонирования,
обработка ведётся в "потоковом" режиме, т.е. формируется матрица,
обработанная часть списка удаляется, матрица транспонируется, новые данные записываются в новый список,
процесс происходит циклично до окончания исходных данных
'''

file_name: str = 'test.txt' # Имя изначального файла
file_name_encrypted: str = 'test_encrypted.txt' # Имя зашифрованного файла
bin_list: list = [] # Список бинарных значений символов
bin_list_copy: list = [] # Копия списка бинарных значений символов для обработки
bin_list_temp: list = [] # Временный список для хранения 8 символов в бинарном виде для формирования матрицы 8x8
bin_list_encrypted: list = [] # Список для хранения обработанной "зашифрованной" бинарной информации
temp_bin: str = '' # Строка для временного хранения бинарного значения символа

# Создаю переменную для хранения номера строки (счётчик строк)

# Создаю пустой словарь для добавления результата выполнения функции
strings_positions = dict()

# Открываю файл file_name в режиме чтения
file = open(file_name, 'r', encoding='utf-8')

# Прохожу циклом по файлу, выбирая каждую строку line отдельно
for line in file.readlines():

# Создаю переменную для хранения номера символа в строке (счётчик символов)
# В каждой строке line прохожу циклом, выбирая каждый символ symbol отдельно
    for symbol in line:
# Функцией ord нахожу номер символа symbol в таблице символов Unicode
# Функцией format полученный номер перевожу в двоичную систему исчисления
        result_bin = format(ord(symbol), 'b').zfill(8)
# Полученное бинарное значение символа добавляю в список bin_list
        bin_list.append(result_bin)

# После выхода из цикла закрываю файл
file.close()

# Делаю копию списка бинарных значений всех символов файла, чтобы работать с ним
bin_list_copy = bin_list.copy()

# Наращиваю количество элементов списка до кратного восьми, чтобы можно было обрабатывать бинарные матрицы 8x8
for i in range((((len(bin_list_copy) // 8) + 1) * 8) - len(bin_list_copy)):
    bin_list_copy.append('00000000')

# Пока список bin_list_copy не пуст, беру данные из него, переношу в матрицу и удаляю из списка
while bin_list_copy:
# Обнуляю временный список для хранения 8 элементов
    bin_list_temp = []

# Методом empty библиотеки NumPy создаю пустой двумерный массив matrix размерностью 8x8
    matrix = np.empty((8, 8), int)
# Циклом вырезаю исходные данные из списка bin_list_copy
    for i in range(8):
# Заполняю временный список
        bin_list_temp.append(bin_list_copy.pop(0))
        for j in range(8):
# Посимвольно заполняю двумерный массив-матрицу matrix 8x8 бинарными данными (1 и 0)
            matrix[i][j] = bin_list_temp[i][j:j + 1]
# Методом transpose полученную матрицу транпонирую
    matrix_transpose = matrix.transpose()

# Перемещение элементов зашифрованной матрицы в итоговый зашифрованный список
    for i in range(8):
# temp_bin - строка для временного хранения 8 символов, собранных из строки двумерной зашифрованной матрицы matrix_transpose
        temp_bin = ''
        for j in range(8):
            temp_bin += str(matrix_transpose[i][j])
# Добавляю записи в зашифрованный список
        bin_list_encrypted.append(temp_bin)

# Запись зашифрованной информации в новый файл file_name_encrypted
# Открываю файл file_name_encrypted в режиме записи
file = open(file_name_encrypted, 'w', encoding='utf-8')

# Для удаления нулевых символов "хвоста" разворачиваю список
bin_list_encrypted.reverse()

# Бесконечный цикл
while True:
# Если первый элемент - нулевой символ, он удаляется
    if bin_list_encrypted[0] == '00000000':
        bin_list_encrypted.pop(0)
# Если нет, цикл останавливается
    else:
        break

# Список разворачивается обратно в исходное состояние
bin_list_encrypted.reverse()

# Циклом прохожу по списку bin_list_encrypted, каждый элемент перевожу в символ и записываю в файл
for i in range(len(bin_list_encrypted)):
    file.write(chr(int(bin_list_encrypted[i], 2)))

# Закрываю зашифрованный файл
file.close()
